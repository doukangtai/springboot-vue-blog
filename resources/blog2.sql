/*
 Navicat Premium Data Transfer

 Source Server         : aliyun
 Source Server Type    : MySQL
 Source Server Version : 50731
 Source Host           : 47.105.170.162:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 50731
 File Encoding         : 65001

 Date: 14/08/2021 23:09:09
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  `content` text CHARACTER SET utf8 COLLATE utf8_bin NULL,
  `date` datetime(0) NULL DEFAULT NULL,
  `view` int(11) NULL DEFAULT NULL,
  `praise` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 33 CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (23, '生产者消费者问题', '```java\n// synchronized\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Goods goods = new Goods(2);\n        Produce p1 = new Produce(goods);\n        Produce p2 = new Produce(goods);\n        Produce p3 = new Produce(goods);\n        Consume c1 = new Consume(goods);\n        Consume c2 = new Consume(goods);\n        Consume c3 = new Consume(goods);\n        c1.start();\n        c2.start();\n        c3.start();\n        p1.start();\n        p2.start();\n        p3.start();\n    }\n}\n\nclass Produce extends Thread {\n    private Goods goods;\n\n    public Produce(Goods goods) {\n        this.goods = goods;\n    }\n\n    @Override\n    public void run() {\n        goods.produce();\n    }\n}\n\nclass Consume extends Thread {\n    private Goods goods;\n\n    public Consume(Goods goods) {\n        this.goods = goods;\n    }\n\n    @Override\n    public void run() {\n        goods.consume();\n    }\n}\n\nclass Goods {\n    private int size;\n    private int count;\n    private final Queue<Object> queue = new LinkedList<>();\n\n    public Goods(int size) {\n        this.size = size;\n    }\n\n    public void produce() {\n        synchronized (queue) {\n            while (count >= size) {\n                System.out.println(\"队列满\");\n                try {\n                    queue.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            queue.offer(new Object());\n            count++;\n            System.out.println(\"生产了一件产品\");\n            queue.notifyAll();\n        }\n    }\n\n    public void consume() {\n        synchronized (queue) {\n            while (queue.isEmpty()) {\n                System.out.println(\"队列空\");\n                try {\n                    queue.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            queue.poll();\n            count--;\n            System.out.println(\"消费了一件商品\");\n            queue.notifyAll();\n        }\n    }\n}\n\n```\n\n\n\n```java\n// 阻塞队列\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Goods goods = new Goods(new LinkedBlockingQueue<>(2));\n        Produce p1 = new Produce(goods);\n        Produce p2 = new Produce(goods);\n        Produce p3 = new Produce(goods);\n        Consume c1 = new Consume(goods);\n        Consume c2 = new Consume(goods);\n        Consume c3 = new Consume(goods);\n        c1.start();\n        c2.start();\n        c3.start();\n        p1.start();\n        p2.start();\n        p3.start();\n    }\n}\n\nclass Produce extends Thread {\n    private Goods goods;\n\n    public Produce(Goods goods) {\n        this.goods = goods;\n    }\n\n    @Override\n    public void run() {\n        goods.produce();\n    }\n}\n\nclass Consume extends Thread {\n    private Goods goods;\n\n    public Consume(Goods goods) {\n        this.goods = goods;\n    }\n\n    @Override\n    public void run() {\n        goods.consume();\n    }\n}\n\nclass Goods {\n    private BlockingQueue<Object> queue;\n\n    public Goods(BlockingQueue<Object> queue) {\n        this.queue = queue;\n    }\n\n    public void produce() {\n        try {\n            queue.put(new Object());\n            System.out.println(\"生产了一件商品\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void consume() {\n        try {\n            queue.take();\n            System.out.println(\"消费了一件商品\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n\n\n```java\n// ReentrantLock 实现\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        ReentrantLock lock = new ReentrantLock();\n        Goods goods = new Goods(2, lock, lock.newCondition(), lock.newCondition());\n        Produce p1 = new Produce(goods);\n        Produce p2 = new Produce(goods);\n        Produce p3 = new Produce(goods);\n        Consume c1 = new Consume(goods);\n        Consume c2 = new Consume(goods);\n        Consume c3 = new Consume(goods);\n        c1.start();\n        c2.start();\n        p1.start();\n        p2.start();\n        c3.start();\n        p3.start();\n    }\n}\n\nclass Produce extends Thread {\n    private Goods goods;\n\n    public Produce(Goods goods) {\n        this.goods = goods;\n    }\n\n    @Override\n    public void run() {\n        goods.produce();\n    }\n}\n\nclass Consume extends Thread {\n    private Goods goods;\n\n    public Consume(Goods goods) {\n        this.goods = goods;\n    }\n\n    @Override\n    public void run() {\n        goods.consume();\n    }\n}\n\nclass Goods {\n    private Queue<Object> queue = new LinkedList<>();\n    private int size;\n    private int count;\n    private ReentrantLock lock;\n    private Condition full;\n    private Condition empty;\n\n    public Goods(int size, ReentrantLock lock, Condition full, Condition empty) {\n        this.size = size;\n        this.lock = lock;\n        this.full = full;\n        this.empty = empty;\n    }\n\n    public void produce() {\n        lock.lock();\n        try {\n            while (count >= size) {\n                System.out.println(\"队列满\");\n                try {\n                    full.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            queue.offer(new Object());\n            count++;\n            System.out.println(\"生产一件商品\");\n            empty.signalAll();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void consume() {\n        lock.lock();\n        try {\n            while (count <= 0) {\n                System.out.println(\"队列空\");\n                try {\n                    empty.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            queue.poll();\n            count--;\n            System.out.println(\"消费一件商品\");\n            full.signalAll();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```', '2021-07-09 19:24:21', 8, 0);
INSERT INTO `article` VALUES (24, '哲学家就餐问题', '```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n//        ReentrantLock[] forks = {\n//                new ReentrantLock(),\n//                new ReentrantLock(),\n//                new ReentrantLock(),\n//                new ReentrantLock(),\n//                new ReentrantLock()\n//        };\n//        Philosopher p1 = new Philosopher(0, forks);\n//        Philosopher p2 = new Philosopher(1, forks);\n//        Philosopher p3 = new Philosopher(2, forks);\n//        Philosopher p4 = new Philosopher(3, forks);\n//        Philosopher p5 = new Philosopher(4, forks);\n//        p1.start();\n//        p2.start();\n//        p3.start();\n//        p4.start();\n//        p5.start();\n\n        ReentrantLock[] forks = {\n                new ReentrantLock(),\n                new ReentrantLock(),\n                new ReentrantLock(),\n                new ReentrantLock(),\n                new ReentrantLock()\n        };\n        Semaphore count = new Semaphore(4);\n        Philosopher2 p1 = new Philosopher2(0, forks, count);\n        Philosopher2 p2 = new Philosopher2(1, forks, count);\n        Philosopher2 p3 = new Philosopher2(2, forks, count);\n        Philosopher2 p4 = new Philosopher2(3, forks, count);\n        Philosopher2 p5 = new Philosopher2(4, forks, count);\n        p1.start();\n        p2.start();\n        p3.start();\n        p4.start();\n        p5.start();\n    }\n}\n\nclass Philosopher2 extends Thread {\n    private int num;\n    private ReentrantLock[] forks;\n    private Semaphore count;\n\n    public Philosopher2(int num, ReentrantLock[] forks, Semaphore count) {\n        this.num = num;\n        this.forks = forks;\n        this.count = count;\n    }\n\n    @Override\n    public void run() {\n        thinking();\n        try {\n            count.acquire();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        int leftFork = (num + 1) % 5;\n        int rightFork = num;\n        forks[leftFork].lock();\n        forks[rightFork].lock();\n        takeLeftFork();\n        takeRightFork();\n        eat();\n        putLeftFork();\n        putRightFork();\n        forks[leftFork].unlock();\n        forks[rightFork].unlock();\n        count.release();\n    }\n\n    private void thinking() {\n        System.out.println(\"第\" + num + \"位哲学家在思考\");\n        sleep();\n    }\n\n    private void sleep() {\n        try {\n            Thread.sleep(new Random().nextInt(1000));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void putRightFork() {\n        System.out.println(\"第\" + num + \"位哲学家放下了右手筷子\");\n    }\n\n    private void putLeftFork() {\n        System.out.println(\"第\" + num + \"位哲学家放下了左手筷子\");\n    }\n\n    private void eat() {\n        System.out.println(\"第\" + num + \"位哲学家在吃饭\");\n        sleep();\n    }\n\n    private void takeRightFork() {\n        System.out.println(\"第\" + num + \"位哲学家拿起了左手筷子\");\n    }\n\n    private void takeLeftFork() {\n        System.out.println(\"第\" + num + \"位哲学家拿起了右手筷子\");\n    }\n}\n\nclass Philosopher extends Thread {\n    private int num;\n    private ReentrantLock[] forks;\n\n    public Philosopher(int num, ReentrantLock[] forks) {\n        this.num = num;\n        this.forks = forks;\n    }\n\n    @Override\n    public void run() {\n        thinking();\n        int leftFork = (num + 1) % 5;\n        int rightFork = num;\n        if (num % 2 == 1) {\n            forks[leftFork].lock();\n            forks[rightFork].lock();\n        } else {\n            forks[rightFork].lock();\n            forks[leftFork].lock();\n        }\n        takeLeftFork();\n        takeRightFork();\n        eat();\n        putLeftFork();\n        putRightFork();\n        forks[leftFork].unlock();\n        forks[rightFork].unlock();\n    }\n\n    private void thinking() {\n        System.out.println(\"第\" + num + \"位哲学家在思考\");\n        sleep();\n    }\n\n    private void sleep() {\n        try {\n            Thread.sleep(new Random().nextInt(1000));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void putRightFork() {\n        System.out.println(\"第\" + num + \"位哲学家放下了右手筷子\");\n    }\n\n    private void putLeftFork() {\n        System.out.println(\"第\" + num + \"位哲学家放下了左手筷子\");\n    }\n\n    private void eat() {\n        System.out.println(\"第\" + num + \"位哲学家在吃饭\");\n        sleep();\n    }\n\n    private void takeRightFork() {\n        System.out.println(\"第\" + num + \"位哲学家拿起了左手筷子\");\n    }\n\n    private void takeLeftFork() {\n        System.out.println(\"第\" + num + \"位哲学家拿起了右手筷子\");\n    }\n}\n```', '2021-07-13 20:25:11', 6, 1);
INSERT INTO `article` VALUES (25, 'SpringMVC 核心流程', '```java\n// DispatchServlet核心方法doDispatch ---> 调度每个Request处理逻辑。\npublic class DispatcherServlet extends FrameworkServlet {\n    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        HttpServletRequest processedRequest = request;\n        HandlerExecutionChain mappedHandler = null;\n        boolean multipartRequestParsed = false;\n        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n        try {\n            try {\n                ModelAndView mv = null;\n                Object dispatchException = null;\n\n                try {\n                    processedRequest = this.checkMultipart(request);\n                    multipartRequestParsed = processedRequest != request;\n                    // 根据HttpServletRequest到HandlerMapping中调用getHandler方法，获取具体目标handler和HandlerInterceptor包装成HandlerExecutionChain\n                    mappedHandler = this.getHandler(processedRequest);\n                    if (mappedHandler == null) {\n                        this.noHandlerFound(processedRequest, response);\n                        return;\n                    }\n\n                    // 根据目标handler获取handlerAdapters集合中第一个if (adapter.supports(handler)) {return adapter;}的HandlerAdapter\n                    HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler());\n                    String method = request.getMethod();\n                    boolean isGet = \"GET\".equals(method);\n                    if (isGet || \"HEAD\".equals(method)) {\n                        long lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n                        if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) && isGet) {\n                            return;\n                        }\n                    }\n\n                    // 在执行具体目标handler之前需要执行拦截器的preHandle方法，调用包装在HandlerExecutionChain中的interceptor的preHandle方法\n                    if (!mappedHandler.applyPreHandle(processedRequest, response)) {\n                        return;\n                    }\n\n                    // 通过获取到的适配器调用目标handler执行自定义逻辑，返回ModelAndView对象\n                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n                    if (asyncManager.isConcurrentHandlingStarted()) {\n                        return;\n                    }\n\n                    // 为ModelAndView设置视图名mv.setViewName(defaultViewName);\n                    this.applyDefaultViewName(processedRequest, mv);\n                    // 拦截器后置处理\n                    mappedHandler.applyPostHandle(processedRequest, response, mv);\n                } catch (Exception var20) {\n                    dispatchException = var20;\n                } catch (Throwable var21) {\n                    dispatchException = new NestedServletException(\"Handler dispatch failed\", var21);\n                }\n\n                // 最后根据获取到的ModelAndView利用逻辑视图渲染真正的目标页面\n                this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);\n            } catch (Exception var22) {\n                this.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);\n            } catch (Throwable var23) {\n                this.triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(\"Handler processing failed\", var23));\n            }\n\n        } finally {\n            if (asyncManager.isConcurrentHandlingStarted()) {\n                if (mappedHandler != null) {\n                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n                }\n            } else if (multipartRequestParsed) {\n                this.cleanupMultipart(processedRequest);\n            }\n\n        }\n    }\n}\n```', '2021-06-15 18:26:26', 8, 2);
INSERT INTO `article` VALUES (26, '单例 - 双重锁', 'public class Singleton {\n\n    private volatile static Singleton uniqueInstance;\n\n    private Singleton() {\n    }\n\n    public static Singleton getUniqueInstance() {\n        if (uniqueInstance == null) {\n            synchronized (Singleton.class) {\n                if (uniqueInstance == null) {\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n}\n\n\nvolatile 禁止指令重排', '2021-07-15 20:32:02', 3, 0);
INSERT INTO `article` VALUES (27, '排序算法', '    /**\n     * 交换函数\n     *\n     * @param arr\n     * @param a\n     * @param b\n     */\n    static void swap(int[] arr, int a, int b) {\n        int t = arr[a];\n        arr[a] = arr[b];\n        arr[b] = t;\n    }\n\n    /**\n     * 冒泡排序\n     *\n     * @param arr\n     */\n    static void bubbleSort(int[] arr) {\n        for (int end = arr.length - 1; end > 0; end--) {\n            boolean flag = true;\n            for (int i = 0; i < end; i++) {\n                if (arr[i] > arr[i + 1]) {\n                    swap(arr, i, i + 1);\n                    flag = false;\n                }\n            }\n            if (flag) {\n                break;\n            }\n        }\n    }\n\n    /**\n     * 选择排序\n     *\n     * @param arr\n     */\n    static void selectSort(int[] arr) {\n        for (int i = 0; i < arr.length - 1; i++) {\n            int temp = i;\n            for (int j = i + 1; j < arr.length; j++) {\n                if (arr[temp] > arr[j]) {\n                    temp = j;\n                }\n            }\n            swap(arr, temp, i);\n        }\n    }\n\n    /**\n     * 插入排序1\n     *\n     * @param arr\n     */\n    static void insertSort1(int[] arr) {\n        for (int i = 1; i < arr.length; i++) {\n            for (int j = i; j > 0 && arr[j] < arr[j - 1]; j--) {\n                swap(arr, j, j - 1);\n            }\n        }\n    }\n\n    /**\n     * 插入排序2\n     *\n     * @param arr\n     */\n    static void insertSort2(int[] arr) {\n        for (int i = 1; i < arr.length; i++) {\n            int key = arr[i];\n            int j;\n            for (j = i - 1; j >= 0 && arr[j] > key; j--) {\n                arr[j + 1] = arr[j];\n            }\n            arr[j + 1] = key;\n        }\n    }\n\n    /**\n     * 二分插入排序\n     *\n     * @param arr\n     */\n    static void binaryInsertSort(int[] arr) {\n        for (int i = 1; i < arr.length; i++) {\n            int key = arr[i];\n            int L = 0;\n            int R = i - 1;\n            while (L <= R) {\n                int M = L + (R - L) / 2;\n                if (key > arr[M]) {\n                    L = M + 1;\n                } else {\n                    R = M - 1;\n                }\n            }\n            for (int j = i - 1; j >= L; j--) {\n                arr[j + 1] = arr[j];\n            }\n            arr[L] = key;\n        }\n    }\n\n    /**\n     * 希尔排序\n     *\n     * @param arr\n     */\n    static void shellSort(int[] arr) {\n        for (int i = arr.length; i > 0; i /= 2) {\n            for (int end = i; end < arr.length; end++) {\n                int key = arr[end];\n                int j;\n                for (j = end - i; j >= 0 && key < arr[j]; j -= i) {\n                    arr[j + i] = arr[j];\n                }\n                arr[j + i] = key;\n            }\n        }\n    }\n\n    /**\n     * 快速排序\n     *\n     * @param arr\n     */\n    static void quickSort(int[] arr, int left, int right) {\n        if (left >= right) {\n            return;\n        }\n        int l = left;\n        int r = right;\n        int key = arr[left];\n        while (l < r) {\n            while (l < r && key <= arr[r]) {\n                r--;\n            }\n            arr[l] = arr[r];\n            while (l < r && key >= arr[l]) {\n                l++;\n            }\n            arr[r] = arr[l];\n        }\n        arr[l] = key;\n        quickSort(arr, left, l - 1);\n        quickSort(arr, l + 1, right);\n    }\n\n    /**\n     * 归并排序\n     *\n     * @param arr\n     */\n    static void mergeSort(int[] arr, int left, int right) {\n        if (left >= right) {\n            return;\n        }\n        int M = left + (right - left) / 2;\n        mergeSort(arr, left, M);\n        mergeSort(arr, M + 1, right);\n        merge(arr, left, M, right);\n    }\n\n    static void merge(int[] arr, int L, int M, int R) {\n        int p1 = L;\n        int p2 = M + 1;\n        int[] temp = new int[R - L + 1];\n        int flag = 0;\n        while (p1 <= M && p2 <= R) {\n            temp[flag++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];\n        }\n        while (p1 <= M) {\n            temp[flag++] = arr[p1++];\n        }\n        while (p2 <= R) {\n            temp[flag++] = arr[p2++];\n        }\n        for (int i = 0; i < temp.length; i++) {\n            arr[L++] = temp[i];\n        }\n    }\n\n    /**\n     * 堆排序\n     *\n     * @param arr\n     */\n    static void heapSort(int[] arr) {\n        if (arr == null || arr.length <= 1) {\n            return;\n        }\n        int heapLastIndex = arr.length - 1;\n        for (int i = (heapLastIndex - 1) / 2; i >= 0; i--) {\n            heapify(arr, i, arr.length);\n        }\n        swap(arr, 0, heapLastIndex);\n        while (heapLastIndex > 0) {\n            heapify(arr, 0, heapLastIndex);\n            swap(arr, 0, --heapLastIndex);\n        }\n    }\n\n    static void heapify(int[] arr, int i, int heapSize) {\n        int max = i;\n        int L = i * 2 + 1;\n        int R = i * 2 + 2;\n        if (L < heapSize && arr[L] > arr[max]) {\n            max = L;\n        }\n        if (R < heapSize && arr[R] > arr[max]) {\n            max = R;\n        }\n        if (max != i) {\n            swap(arr, max, i);\n            heapify(arr, max, heapSize);\n        }\n    }\n\n    /**\n     * 计数排序\n     *\n     * @param arr\n     */\n    static void countSort(int[] arr) {\n        int min = arr[0];\n        int max = arr[0];\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] > max) {\n                max = arr[i];\n            }\n            if (arr[i] < min) {\n                min = arr[i];\n            }\n        }\n        int flag = -min;\n        int[] bucket = new int[max - min + 1];\n        Arrays.fill(bucket, 0);\n        for (int i = 0; i < arr.length; i++) {\n            bucket[arr[i] + flag]++;\n        }\n        int i = 0;\n        int j = 0;\n        while (j < arr.length) {\n            if (bucket[i] != 0) {\n                arr[j++] = i - flag;\n                bucket[i]--;\n            } else {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * 桶排序\n     *\n     * @param arr\n     * @param bucketSize\n     */\n    static void bucketSort(int[] arr, int bucketSize) {\n        int min = arr[0];\n        int max = arr[0];\n        for (int item : arr) {\n            if (item > max) {\n                max = item;\n            }\n            if (item < min) {\n                min = item;\n            }\n        }\n        int bucketCount = (max - min) / bucketSize + 1;\n        ArrayList<ArrayList<Integer>> bucketArr = new ArrayList<>(bucketCount);\n        for (int i = 0; i < bucketCount; i++) {\n            bucketArr.add(new ArrayList<>());\n        }\n        for (int value : arr) {\n            bucketArr.get((value - min) / bucketSize).add(value);\n        }\n        for (ArrayList<Integer> bucket : bucketArr) {\n            Collections.sort(bucket);\n        }\n        int arrSize = 0;\n        for (ArrayList<Integer> bucket : bucketArr) {\n            for (Integer num : bucket) {\n                arr[arrSize++] = num;\n            }\n        }\n    }\n\n    /**\n     * 基数排序\n     *\n     * @param arr\n     */\n    static void radixSort(int[] arr) {\n        int max = arr[0];\n        for (int i : arr) {\n            max = Math.max(max, i);\n        }\n        int maxDigit = 0;\n        while (max != 0) {\n            max /= 10;\n            maxDigit++;\n        }\n        ArrayList<ArrayList<Integer>> bucketArr = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            bucketArr.add(new ArrayList<>());\n        }\n        int mod = 10;\n        int div = 1;\n        for (int i = 0; i < maxDigit; i++, mod *= 10, div *= 10) {\n            for (int j = 0; j < arr.length; j++) {\n                int temp = (arr[j] % mod) / div;\n                bucketArr.get(temp).add(arr[j]);\n            }\n            int index = 0;\n            for (ArrayList<Integer> bucket : bucketArr) {\n                for (Integer num : bucket) {\n                    arr[index++] = num;\n                }\n                bucket.clear();\n            }\n        }\n    }', '2021-07-20 19:03:59', 15, 2);
INSERT INTO `article` VALUES (28, 'TCP 三次握手 四次挥手', '#### 三次握手\n\nTCP连接传输三个阶段:\n\n* 连接建立；\n* 数据传送；\n* 连接释放；\n\nTCP连接的建立采用客户端服务器方式，主动发起连接建立的应用进程叫做客户端(A)，而被动等待连接建立的应用进程叫服务器(B)。\n\n假设运行在一台主机(客户)上的一个进程想与另一台主机（服务器）上的一个进程建立一条连接，客户应用进程首先通知客户TCP，他想建立一个与服务器上某个进程之间的连接，客户中的TCP会用以下步骤与服务器中的TCP建立一条TCP连接:\n\n![5_13.png](http://47.105.170.162:80/upload/image/8113bb34-931b-475a-a048-8e0a3c1e6172.png)\n\n步骤:\n\n* 1)、A 向 B 发送连接请求报文段，SYN=1，ACK=0，选择一个初始的序号 seq = x；\n* 2)、B 收到连接请求报文段，，如果同意建立连接，服务器为该TCP连接分配缓存和变量，向 A 发送连接确认报文段，SYN=1，ACK=1，确认号`ack`为 `x+1`，同时也选择一个初始的序号 seq = y (随机)；\n* 3)、A 收到 B 的连接确认报文段后，为该TCP连接分配缓存和变量，同时还要向 B 发出确认，ACK = 1，确认号为 ack = y+1，序号为 `seq = x+1`(接上一开始的`x`)；(SYN = 0，因为只有在连接请求和连接请求接受的时候才会置为1)；\n* 4)、最后，B收到A确认报文，状态变为ESTABLISHED(连接建立)，双方就可以进行双向通信了；\n\n\n\n#### 四次挥手\n\n过程:\n\n![5_17.png](http://47.105.170.162:80/upload/image/edd96b73-a85a-43fe-9ecd-d4fc49e50bc4.png)\n\n数据传输结束后，通信的双方都可释放连接。现在 A 的应用进程先向其 TCP **发出连接释放报文段**，并停止再发送数据，主动关闭 TCP连接。\n\n- A 把连接释放报文段首部的 FIN = 1，其序号 seq = u，等待 B 的确认。\n- B 发出确认(会送一个确认报文段)，ACK = 1，确认号 ack = u+1，而这个报文段自己的序号 seq = v(随机)。（TCP 服务器进程通知高层应用进程）\n- 从 A 到 B 这个方向的连接就释放了，TCP 连接处于**半关闭状态**。A 不能向 B 发送数据；**B 若发送数据，A 仍要接收**。\n- 当 B 不再需要连接时，发送连接释放请求报文段，FIN=1，ACK =1，seq = w(随机)，确认号ack = u + 1(为什么确认号是一样的，因为在这段时间内，A没有发送数据) (这时B进入`LAST-ACK`(最后确认阶段))。\n- A 收到后发出确认，ACK =1, seq = u + 1（因为FIN要消耗一个序号，所以从u+1开始），进入 TIME-WAIT 状态，等待 2 MSL（2*2 = 4 mins）时间后释放连接。\n- B 收到 A 的确认后释放连接。', '2021-07-28 21:12:35', 10, 1);
INSERT INTO `article` VALUES (29, '最长递增子序列', '[牛客-最长递增子序列](https://www.nowcoder.com/practice/9cf027bf54714ad889d4f30ff0ae5481?tpId=117&&tqId=37796&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)\n```java\npublic int[] LIS(int[] arr) {\n    int[] incr = new int[arr.length];\n    int[] maxLen = new int[arr.length];\n    incr[0] = arr[0];\n    maxLen[0] = 1;\n    int len = 1;\n    for (int i = 1; i < arr.length; i++) {\n        if (arr[i] > incr[len - 1]) {\n            incr[len] = arr[i];\n            maxLen[i] = len + 1;\n            len++;\n        } else {\n            int left = 0;\n            int right = len - 1;\n            while (left < right) {\n                int mid = left + (right - left) / 2;\n                if (arr[i] > incr[mid]) {\n                    left = mid + 1;\n                } else {\n                    right = mid;\n                }\n            }\n            incr[left] = arr[i];\n            maxLen[i] = left + 1;\n        }\n    }\n    int[] res = new int[len];\n    for (int i = arr.length - 1; i >= 0; i--) {\n        if (maxLen[i] == len) {\n            res[--len] = arr[i];\n        }\n    }\n    return res;\n}\n\n```\n', '2021-08-03 08:18:41', 9, 3);
INSERT INTO `article` VALUES (30, 'HashMap1.8', '## put\n\nput过程:\n\n![1566058147404.png](http://47.105.170.162:80/upload/image/2c4e7a06-2cec-4b8c-a870-3eeeeb555601.png)\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\n// 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作\n// 第四个参数 evict 我们这里不关心\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度\n    // 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n\n    else {// 数组该位置有数据\n        Node<K,V> e; K k;\n        // 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是\"相等\"，如果是，取出这个节点\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        // 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            // 到这里，说明数组该位置上是一个链表\n            for (int binCount = 0; ; ++binCount) {\n                // 插入到链表的最后面(Java7 是插入到链表的最前面)\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    // TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个\n                    // 会触发下面的 treeifyBin，也就是将链表转换为红黑树\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                // 如果在该链表中找到了\"相等\"的 key(== 或 equals)\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    // 此时 break，那么 e 为链表中[与要插入的新值的 key \"相等\"]的 node\n                    break;\n                p = e;\n            }\n        }\n        // e!=null 说明存在旧值的key与要插入的key\"相等\"\n        // 对于我们分析的put操作，下面这个 if 其实就是进行 \"值覆盖\"，然后返回旧值\n        if (e != null) {\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    // 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n## get\n\n1、计算 key 的 hash 值，根据 hash 值找到对应数组下标: `hash & (length-1)`\n\n2、判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步\n\n3、判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步\n\n4、遍历链表，直到找到相等(==或equals)的 key\n\n```java\npublic V get(Object key) {\n    //当前节点\n    Node<K, V> e;\n    //获取当前节点，并返回节点的值\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\nfinal Node<K, V> getNode(int hash, Object key) {\n    //当前表\n    Node<K, V>[] tab;\n    Node<K, V> first, e;\n    int n;\n    K k;\n    //如果当前表不为null,且表长度大于0.并且找到桶的位置\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        //如果第一个就和key相等\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            //返回桶的第一个元素\n            return first;\n        //如果第一个节点后面还有接待你\n        if ((e = first.next) != null) {\n            //如果是红黑树\n            if (first instanceof TreeNode)\n                //获取树中的节点\n                return ((TreeNode<K, V>) first).getTreeNode(hash, key);\n            //迭代链表，获取匹配的节点\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    //没找到，返回null\n    return null;\n}\n```\n\n', '2021-08-10 19:28:01', 10, 2);
INSERT INTO `article` VALUES (31, 'try-catch-finally', '```java\npublic int method() {\n    int num = 1;\n    try {\n        System.out.println(\"try\");\n        num++;\n        return num;\n    } catch (Exception e) {\n        System.out.println(\"catch\");\n        num++;\n        return num;\n    } finally {\n        System.out.println(\"finally\");\n        num++;\n        return num;\n    }\n}\n\n// try\n// finally\n// 3\n\n```\n\n```java\npublic int method() {\n    int num = 1;\n    try {\n        System.out.println(\"try\");\n        num++;\n        int i = 10 / 0;\n        return num;\n    } catch (Exception e) {\n        System.out.println(\"catch\");\n        num++;\n        return num;\n    } finally {\n        System.out.println(\"finally\");\n        num++;\n        return num;\n    }\n}\n\n// try\n// catch\n// finally\n// 4\n\n```\n', '2021-08-13 22:55:44', 4, 0);
INSERT INTO `article` VALUES (32, '类加载器', '```java\nprotected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException {\n    synchronized (getClassLoadingLock(name)) {\n        // 首先，检查类是否已经被加载了\n        Class c = findLoadedClass(name);\n        if (c == null) {\n            //没被加载，先委派父ClassLoader或BootStrap ClassLoader去加载\n            try {\n                if (parent != null) {\n                    //委派父ClassLoader，resolve参数固定为false\n                    c = parent.loadClass(name, false);\n                } else {\n                    c = findBootstrapClassOrNull(name);\n                }\n            } catch (ClassNotFoundException e) {\n                //没找到，捕获异常，以便尝试自己加载                \n            }\n            if (c == null) {\n                // 自己去加载，findClass才是当前ClassLoader的真正加载方法\n                c = findClass(name);\n            }\n        }\n        if (resolve) {\n            resolveClass(c);\n        }\n        return c;\n    }\n}\n\n```\n\n### 自定义类加载器\n\n载器步骤：\n\n- 定义一个类，继承 ClassLoader；\n- 重写 findClass 方法；\n\n', '2021-08-14 23:03:49', 5, 1);

-- ----------------------------
-- Table structure for article_category
-- ----------------------------
DROP TABLE IF EXISTS `article_category`;
CREATE TABLE `article_category`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `aid` int(11) NULL DEFAULT NULL,
  `cid` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `aid`(`aid`) USING BTREE,
  INDEX `cid`(`cid`) USING BTREE,
  CONSTRAINT `article_category_ibfk_1` FOREIGN KEY (`aid`) REFERENCES `article` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `article_category_ibfk_2` FOREIGN KEY (`cid`) REFERENCES `category` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 54 CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article_category
-- ----------------------------
INSERT INTO `article_category` VALUES (43, 24, 27);
INSERT INTO `article_category` VALUES (44, 23, 27);
INSERT INTO `article_category` VALUES (45, 25, 2);
INSERT INTO `article_category` VALUES (47, 26, 28);
INSERT INTO `article_category` VALUES (48, 27, 21);
INSERT INTO `article_category` VALUES (49, 28, 26);
INSERT INTO `article_category` VALUES (50, 29, 21);
INSERT INTO `article_category` VALUES (51, 30, 25);
INSERT INTO `article_category` VALUES (52, 31, 25);
INSERT INTO `article_category` VALUES (53, 32, 25);

-- ----------------------------
-- Table structure for article_tag
-- ----------------------------
DROP TABLE IF EXISTS `article_tag`;
CREATE TABLE `article_tag`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `aid` int(11) NULL DEFAULT NULL,
  `tid` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `aid`(`aid`) USING BTREE,
  INDEX `tid`(`tid`) USING BTREE,
  CONSTRAINT `article_tag_ibfk_1` FOREIGN KEY (`aid`) REFERENCES `article` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `article_tag_ibfk_2` FOREIGN KEY (`tid`) REFERENCES `tag` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 89 CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article_tag
-- ----------------------------
INSERT INTO `article_tag` VALUES (78, 24, 54);
INSERT INTO `article_tag` VALUES (79, 23, 54);
INSERT INTO `article_tag` VALUES (80, 25, 51);
INSERT INTO `article_tag` VALUES (82, 26, 55);
INSERT INTO `article_tag` VALUES (83, 27, 56);
INSERT INTO `article_tag` VALUES (84, 28, 57);
INSERT INTO `article_tag` VALUES (85, 29, 58);
INSERT INTO `article_tag` VALUES (86, 30, 59);
INSERT INTO `article_tag` VALUES (87, 31, 60);
INSERT INTO `article_tag` VALUES (88, 32, 61);

-- ----------------------------
-- Table structure for category
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `category` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 29 CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES (2, 'Java框架');
INSERT INTO `category` VALUES (3, '开发工具');
INSERT INTO `category` VALUES (4, '数据库');
INSERT INTO `category` VALUES (21, '数据结构与算法');
INSERT INTO `category` VALUES (24, 'JVM');
INSERT INTO `category` VALUES (25, 'Java');
INSERT INTO `category` VALUES (26, '计算机网络');
INSERT INTO `category` VALUES (27, '操作系统');
INSERT INTO `category` VALUES (28, '设计模式');

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `tag` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 62 CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES (51, 'SpringMVC');
INSERT INTO `tag` VALUES (54, '进程同步');
INSERT INTO `tag` VALUES (55, '设计模式');
INSERT INTO `tag` VALUES (56, '排序');
INSERT INTO `tag` VALUES (57, 'TCP');
INSERT INTO `tag` VALUES (58, '牛客算法题');
INSERT INTO `tag` VALUES (59, '集合');
INSERT INTO `tag` VALUES (60, '关键字');
INSERT INTO `tag` VALUES (61, '类加载器');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (5, 'admin', '$2a$10$DVo7SHQbAjO5a.ZtziLYKe0wVTNtlU6wX9ssf.sVDnlRQDJRpvcX6', '超级管理员');
INSERT INTO `user` VALUES (6, 'dkt', 'e10adc3949ba59abbe56e057f20f883e', '小窦');

SET FOREIGN_KEY_CHECKS = 1;
